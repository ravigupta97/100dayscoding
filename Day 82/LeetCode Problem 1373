Given a binary tree root, the task is to return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 

Example 1:



Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
Output: 20
Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.
Example 2:



Input: root = [4,3,null,1,2]
Output: 2
Explanation: Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.
Example 3:

Input: root = [-4,-2,-5]
Output: 0
Explanation: All values are negatives. Return an empty BST.
Example 4:

Input: root = [2,1,3]
Output: 6
Example 5:

Input: root = [5,4,8,3,null,6,3]
Output: 7
 

Constraints:

The given binary tree will have between 1 and 40000 nodes.
Each node's value is between [-4 * 10^4 , 4 * 10^4].







/*
Solved by using the logic that if given node value is larger than maximum of leftsubtree, and smaller than minimum of right subtree 
plus left and right subtree are BST then the given tree sum is considered and global max of answer is stored
*/








/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans;
    
    vector<int> give(TreeNode* root){
        
        if(root==NULL){
            return {true,0,0,0};    
        }
        
        vector<int> l=give(root->left);
        vector<int> r=give(root->right);
        
        if(l[0] and (root->left==NULL or root->val>l[3])){
            if(r[0] and (root->right==NULL or root->val<r[2])){
                
                int sum=root->val+l[1]+r[1];
                ans=max(ans,sum);
                int nowmin=root->left==NULL? root->val:l[2];
                int nowmax=root->right==NULL?root->val:r[3];
                return {true,sum,nowmin,nowmax};
            }
        }
        return {false,0,0,0};
    }    
    
    int maxSumBST(TreeNode* root) {
        ans=0;
        give(root);
        return ans;
    }
};
