Given a string s, we make queries on substrings of s.

For each query queries[i] = [left, right, k], we may rearrange the substring s[left], ..., s[right], and then choose up to k of them to replace with any lowercase English letter. 

If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.

Return an array answer[], where answer[i] is the result of the i-th query queries[i].

Note that: Each letter is counted individually for replacement so if for example s[left..right] = "aaa", and k = 2, we can only replace two of the letters.  (Also, note that the initial string s is never modified by any query.)

 

Example :

Input: s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
Output: [true,false,false,true,true]
Explanation:
queries[0] : substring = "d", is palidrome.
queries[1] : substring = "bc", is not palidrome.
queries[2] : substring = "abcd", is not palidrome after replacing only 1 character.
queries[3] : substring = "abcd", could be changed to "abba" which is palidrome. Also this can be changed to "baab" first rearrange it "bacd" then replace "cd" with "ab".
queries[4] : substring = "abcda", could be changed to "abcba" which is palidrome.
 

Constraints:

1 <= s.length, queries.length <= 10^5
0 <= queries[i][0] <= queries[i][1] < s.length
0 <= queries[i][2] <= s.length
s only contains lowercase English letters.






/*
Solved by counting all the char at every index which is no. of char upto that index then find count of every char between start and end point of each query.
*/






class Solution {
public:
    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {
        vector<bool>ans;
        vector<vector<int> >v(26,vector<int>(s.size()+1,0));
		
        for(int i=0;i<s.size();i++)
        {
            for(int j=0;j<26;j++)
            {
                if(s[i]-'a'==j)v[j][i+1]=v[j][i]+1;
                else v[j][i+1]=v[j][i];
            }
        }
        
        for(int i=0;i<q.size();i++)
        {
            int start=q[i][0],end=q[i][1]+1,c=q[i][2],t=0;
			
            for(int i=0;i<26;i++)
            {
                t+=(v[i][end]-v[i][start])%2;
            }
            if(c>=t/2)ans.push_back(1);
            else ans.push_back(0);
        }
        return ans;
    }
};
